package com.fdmgroup.routePlanner.algorithm;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;

import com.fdmgroup.routePlanner.exception.RoutePlannerException;
import com.fdmgroup.routePlanner.nodes.INode;
import com.fdmgroup.routePlanner.spring.SpringBeanRetriever;

/**
 * K-shortest path routing algorithm implementation of the <code>IPathAlgorithm</code> interface. 
 * @see IPathAlgorithm
 * @author yip.fong
 * @author jessica.gonsalves
 *
 */
public class KPathAlgorithm implements IPathAlgorithm {

	/**
	 *  This is a <code>List</code> of incomplete paths that have not reached the destination yet.
	 *  The paths are represented as a <code>List</code> of <code>INode</code>s.
	 */
	private List<List<INode>> incompletePaths;
	
	/**
	 *  This is the maximum number of routes that can be generated by the <code>getRoutes</code> method.
	 */
	private int maxRoutes;
	
	/**
	 *  This number represents the amount of completed paths with different costs.
	 */
	private int completeRoutes = 0;
	
	/**
	 * Default constructor, all the fields will be null by default. Before any method can be used the following 
	 * fields need to be set:
	 * <li> incompletePaths
	 * <li> maxRoutes
	 */
	public KPathAlgorithm(){
		
	}
	
	public List<List<INode>> getIncompletePaths() {
		return incompletePaths;
	}

	public void setIncompletePaths(List<List<INode>> incompletePaths) {
		this.incompletePaths = incompletePaths;
	}
	
	public int getMaxRoutes() {
		return maxRoutes;
	}

	public void setMaxRoutes(int maxRoutes) {
		this.maxRoutes = maxRoutes;
	}

	/**
	 * This method returns the last node from a given path.
	 * @param path a <code>List</code> of <code>INode</code>s representing a path
	 * @return the last <code>INode</code> from the path
	 * @throws RoutePlannerException if the argument passed in is null; if the <code>List</code> passed in
	 * is empty
	 */
	private INode getPathLastNode(List<INode> path) throws RoutePlannerException{
		if(path == null){
			throw new RoutePlannerException("Argument passed in is null.");
		}
		if(path.isEmpty()){
			throw new RoutePlannerException("List representing the path is empty.");
		}
		return path.get(path.size()-1);
	}
	
	/**
	 * This method retrieves the paths that are connected to the <code>INode</code> passed in.
	 * @param node the <code>INode</code> passed in as the argument to which the paths will be connected to
	 * @return <code>Collection</code> of <code>List</code> of <code>INode</code>s 
	 * @throws RoutePlannerException if the argument passed in is null; if the List passed in is empty
	 */
	@SuppressWarnings("unchecked")
	private Collection<List<INode>> checkOutConnectingPaths (INode node) throws RoutePlannerException{
		
		Collection<List<INode>> connectedPaths = (Collection<List<INode>>) SpringBeanRetriever.getBean("aList");
		
		for(List<INode> path : incompletePaths){
			if(getPathLastNode(path).equals(node)){
				connectedPaths.add(path);
			}
		}
		incompletePaths.removeAll(connectedPaths);
		return connectedPaths;
	}
	
	/**
	 * This method adds all <code>INode</code>s that are connected to the source <code>INode</code> to the
	 * <code>Queue</code> passed in. 
	 * @param source the start point <code>INode</code>
	 * @param connectedNodes <code>Queue</code> that the connected <code>INode</code>s will be added to
	 */
	@SuppressWarnings("unchecked")
	private void populateConnectedNodes (INode source, Queue<INode> connectedNodes) {
		connectedNodes.add(source);
		Queue<INode> uncheckedNodes;
		try {
			uncheckedNodes = (Queue<INode>) SpringBeanRetriever.getBean("lList");
		} catch (RoutePlannerException e) {
			uncheckedNodes = new LinkedList<INode>();
		}
		
		uncheckedNodes.addAll(source.getAdjacentNodes().keySet());
		while(!uncheckedNodes.isEmpty()){
			INode tempNode = uncheckedNodes.poll();
			connectedNodes.add(tempNode);
			for(INode node : tempNode.getAdjacentNodes().keySet()){
				if(!uncheckedNodes.contains(node) && !connectedNodes.contains(node)){
					uncheckedNodes.add(node);
				}
			}
		}
	}
	
	/**
	 * This method sets up the starting path from the <code>INode</code> passed in. This path will be inserted into
	 * the <code>incompletePaths</code>.
	 * @param startNode <code>INode</code> which will be the start point of the path
	 */
	@SuppressWarnings("unchecked")
	private void setUpStartPath(INode startNode){
		List<INode> initialPath = null;
		try {
			initialPath = (List<INode>) SpringBeanRetriever.getBean("aList");
		} catch (RoutePlannerException e) {
			initialPath = new ArrayList<INode>();
		}
		
		initialPath.add(startNode);
		incompletePaths.add(initialPath);
	}
	
	/**
	 * This method is used to determine if a path has reached its final point, dead end. A path is considered dead
	 * if a unique <code>INode</code> cannot be added to the path. 
	 * @param path represented by a <code>List</code> of <code>INode</code>s
	 * @return true if the path is dead, false if the path is still alive
	 */
	private boolean pathIsDead(List<INode> path){
		INode lastNode = path.get(path.size()-1);
		INode secondToLastNode = null;
		if(path.size() > 1){
			secondToLastNode = path.get(path.size()-2);
		}
		if(lastNode.getAdjacentNodes().keySet().size() == 0){
			return true;
		}
		if(lastNode.getAdjacentNodes().keySet().size() == 1 && secondToLastNode != null){
			return true;
		}
		return false;
	}
	
	/**
	 * This method adds paths to the <code>List</code> of incomplete paths. Only paths that are still alive
	 * will be added. This method also enforces the number of paths that end with the same <code>INode</code>
	 * will not be larger than the <code>maxRoutes</code>.
	 * @param pathsToCheckIn the new paths being added 
	 * @throws RoutePlannerException if the paths have consecutive nodes that are the same; 
	 * if no connections exist between two consecutive nodes in any of the paths
	 */
	private void checkInPaths(List<List<INode>> pathsToCheckIn) throws RoutePlannerException{
		for(List<INode> path : pathsToCheckIn){
			int pathsToNode = 0;
			INode tempLastNode = getPathLastNode(path);
			for(List<INode> incompletePath : incompletePaths){
				if(getPathLastNode(incompletePath).equals(tempLastNode)){
					pathsToNode++;
				}
			}
			if(!pathIsDead(path) && pathsToNode < maxRoutes){
				incompletePaths.add(path);
			}
			else if (!pathIsDead(path) && pathsToNode >= maxRoutes){
				int pathCost = getPathCost(path);
				List<INode> existingPath = getMostExpensivePathToNode(incompletePaths, tempLastNode);
				int existingPathCost = getPathCost(existingPath);
				if(pathCost < existingPathCost){
					incompletePaths.remove(existingPath);
					incompletePaths.add(path);
				}
				else if(pathCost == existingPathCost){
					incompletePaths.add(path);
				}
			}
		}
		pathsToCheckIn.clear();
	}
	
	/**
	 * This method returns the most expensive path to the node passed in as the argument.
	 * @param paths <code>List</code> of <code>List</code> of <code>INode</code> representing the 
	 * <code>List</code> of paths
	 * @param node the <code>INode</code> that determines which paths to return
	 * @return <code>List</code> of <code>INode</code> representing the most expensive path
	 * @throws RoutePlannerException if the argument passed in is null; if the List passed in is empty
	 */
	private List<INode> getMostExpensivePathToNode(List<List<INode>> paths, INode node) throws RoutePlannerException{
		int maxCost = 0;
		int maxCostIndex = 0;
		for(int i = 0; i < paths.size(); i++){
			List<INode> path = paths.get(i);
			if(getPathLastNode(path).equals(node)){
				int pathCost = getPathCost(path);
				if(pathCost > maxCost){
					maxCost = pathCost;
					maxCostIndex = i;
				}
			}
		}
		return paths.get(maxCostIndex);
	}
	
	/**
	 * This method will add new paths to the <code>List</code> of completed paths. If the maximum number
	 * of paths have been reached, a new path will only be added if it is cheaper than the most expensive path in the 
	 * <code>List</code> of completed paths.
	 * @param newPath the new path being added 
	 * @param completedPaths the <code>List</code> of completed paths
	 * @throws RoutePlannerException if the path has consecutive nodes that are the same; 
	 * if no connections exist between two consecutive nodes
	 */
	private void updateCompletedPaths(List<INode> newPath, List<List<INode>> completedPaths) throws RoutePlannerException{
		int newPathCost = getPathCost(newPath);
		int mostExpensivePathCost = -1;
		if(!completedPaths.isEmpty()){
			List<INode> mostExpensiveCompletePath = getMostExpensivePathToNode(completedPaths, getPathLastNode(newPath));
			mostExpensivePathCost = getPathCost(mostExpensiveCompletePath);
		}
		
		completedPaths.add(newPath);
		
		if(completeRoutes >= maxRoutes && newPathCost != mostExpensivePathCost){
			removeMostExpensivePath(completedPaths);
		}
		completeRoutes = getUniquePathCostCount(completedPaths);
	}
	
	/**
	 * This method returns a number representing the number of unique path costs from the paths passed in.
	 * @param paths the <code>List</code> of <code>List</code> of <code>INode</code> 
	 * @return an <code>Integer</code> representing the number of unique path costs
	 * @throws RoutePlannerException  if the path has consecutive nodes that are the same; 
	 * if no connections exist between two consecutive nodes
	 */
	@SuppressWarnings("unchecked")
	private int getUniquePathCostCount(List<List<INode>> paths) throws RoutePlannerException{
		Set<Integer> costSet;
		try {
			costSet = (Set<Integer>) SpringBeanRetriever.getBean("hSet");
		} catch (RoutePlannerException e) {
			costSet = new HashSet<Integer>();
		}
		for(List<INode> path : paths){
			costSet.add(getPathCost(path));
		}
		
		return costSet.size();
	}
	
	/**
	 * This method removes the most expensive path from a <code>List</code> of paths.
	 * @param paths <code>List</code> of <code>List</code> of <code>INode</code>s representing
	 * the paths from which the most expensive route will be removed
	 */
	private void removeMostExpensivePath(List<List<INode>> paths){
		int maxPathCost = 0;
		int maxCostPathIndex = 0;
		for(int i = 0; i < paths.size(); i++){
			try {
				int tempCost = getPathCost(paths.get(i));
				if(tempCost > maxPathCost){
					maxPathCost = tempCost;
					maxCostPathIndex = i;
				}
			} catch (RoutePlannerException e) {
				maxPathCost = Integer.MAX_VALUE  - 1;
				maxCostPathIndex = i;
			}
		}
		paths.remove(maxCostPathIndex);
	}
	
	/**
	 * This method is used to generate one or more routes between a source and destination.  
	 * @param source the starting point
	 * @param destination the end point
	 * @return a <code>List</code> of a <code>List</code> of <code>INode</code>
	 * @throws RoutePlannerException if source or destination is null; if source is the destination;
	 * if the source is not connected to the destination
	 */
	@SuppressWarnings("unchecked")
	@Override
	public List<List<INode>> getRoutes(INode source, INode destination) throws RoutePlannerException {
		if(source == null || destination == null){
			throw new RoutePlannerException("Error: Start node or destination node is null.");
		}
		if(source.equals(destination)){
			throw new RoutePlannerException("Error: Start node is equal to destination node.");
		}
		
		Queue<INode> unvisitedNodes =  (Queue<INode>) SpringBeanRetriever.getBean("lList");
		
		populateConnectedNodes(source, unvisitedNodes);
		if(!unvisitedNodes.contains(destination)){
			throw new RoutePlannerException("Error: Start node has no connection to destination node.");
		}
		
		setUpStartPath(source);
		List<List<INode>> pathsToCheckIn = (List<List<INode>>) SpringBeanRetriever.getBean("aList");
		List<List<INode>> completedPaths = (List<List<INode>>) SpringBeanRetriever.getBean("aList");
		while(!incompletePaths.isEmpty() && !unvisitedNodes.isEmpty()){
			INode currentNode = unvisitedNodes.poll();
			Collection<List<INode>> connectedPaths = checkOutConnectingPaths(currentNode);
			for(INode neighborNode : currentNode.getAdjacentNodes().keySet()){
				for(List<INode> path : connectedPaths){
					if(!path.contains(neighborNode)){
						List<INode> newPath = (List<INode>) SpringBeanRetriever.getBean("aList");
						newPath.addAll(path);
						if(!newPath.contains(neighborNode)){
							newPath.add(neighborNode);
							if(neighborNode.equals(destination)){
								updateCompletedPaths(newPath, completedPaths);
							}
							else{
								pathsToCheckIn.add(newPath);
							}
						}
					}
				}
			}
			checkInPaths(pathsToCheckIn);
		}
		return completedPaths;
	}

	/**
	 * This method returns a number representing the total cost of a path.
	 * @param a <code>List</code> of <code>INode</code>s representing a path.
	 * @throws RoutePlannerException if the path has consecutive nodes that are the same; 
	 * if no connections exist between two consecutive nodes
	 */
	@Override
	public int getPathCost(List<INode> path) throws RoutePlannerException {
		int cost = 0;
		INode currentNode;
		INode nextNode;
		for(int i = 0; i < path.size() -1; i++){
			currentNode = path.get(i);
			nextNode = path.get(i+1);
			if(currentNode.equals(nextNode)){
				throw new RoutePlannerException("Path given has consecutive nodes that are the same.");
			}
			if(currentNode.getAdjacentNodes().keySet().contains(nextNode)){
				cost = cost + currentNode.getAdjacentNodes().get(nextNode);
			}
			else{
				throw new RoutePlannerException("Two consecutive nodes in this path are not connected.");
			}
		}
		return cost;
	}
}
